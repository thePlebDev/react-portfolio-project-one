
SASS:
- uses the file extension .scss. With a few small exceptions, it's a superset of CSS, which means essentially all valid
CSS is valid SCSS

- nesting rules are super helpful but the deeper the nest the more bandwidth we are using to serve the CSS and the more work
it takes the browser to render it. it is important to keep the selectors shallow
- browsers do not understand Sass, or any other css preprocessors. In order to be able to use Sass in the code. we need
something to turn Sass code into CSS code so that the browser can understand it. One tool that compiles our Sass is Webpack
- you can define variables that cen be peppered across multiple css files

VARIABLES:
- variables can hold a variety of data types.
- variables are defined by a $ immediately preceding the name of the variable and a colon separating the name of the
variable from the value.

    $main-color: blue;

- that is how you define a variable. then we can use it by just adding it to whatever we want like we would normally do in
CSS


- nesting can have a strain on your bandwidth and the specificity. Try to avoid overly using nesting


CSS STYLE CONFLICTS:
- there are 3 things when styles conflict.
1) the stylesheet origin:where the style sheel is coming from
2)selector specificity
3) source order

-user agent style sheets are the styles that the browser applies, they have lower priority, so our styles override them.
- the inline styles will override any declaration applied from our stylesheet.
- don't use IDs in the selector, they ratchet up the specificity a lot.
- don't use !important, this makes the specificity highest it can be and we will have to keep using !import whenever we want
to change something on that elemnent.

- then we are going to use  transition to make the image slider.


RESPONSIVE IMAGES:
- in responsive design, images need special attention, to make sure that they fit on the screen and to
consider the bandwidth of mobile users. when using images, we should make sure that they are well
compressed. User a tool for that.

- the best practice is to create a few copies of an image, each at a different resolution.

EMS AND REMS:
- ems, are the most common relative length unit, are a measure used in typography, refering to a
specified font size. in CSS, 1 em means the font size of the current element; so the em relies on the
size of the element that it is being placed on


REACT SPRING USESPRING:
- so we are going to go the re-render the component with changed props. this is where we set a props variable to the an
object that is set the useSpring() method

CREATING THE NAVBAR CLICK DETECTION:
-so we know what we are going to use the a dom ref, that is for sure.
- we are going to add a useEffect hook to add the click event to the document and we are also going to
make sure that useEffect returns a function so that it cleans up the function. we have to return a function
when it is a click that requires a clean up, this makes sure that we don't get a memory leak.

EFFECTS WITH CLEANUP:
- some effects require a cleanup like setting up a subscription to some external datasource. it is important
to clean up so that we don't introduce a memory leak.
- so if useEffect returns a function react will run it when it is time to clean up.

-an update can be caused by changes to props or state.

- we are going to use the useRef to get the hook value.
- so now we are working on the API.

API AUTHENTICATIONS:
-the application level authentication on this is controleld by either a single query parameter, api_key,
or by using the v4 access token as a Bearer token.
-for our applications authentication we are going to use the api_key authenticaiton

- an API read access token is expected to be sent along as a Authorization header
- user authentication is controlled with a session_id query parameter. you can generate a session_id
by following these steps
1) create a new request token
2) get the user to authorize the request token
3) Create a new session id with the authorized request token

- there are also guest sessions. they just have limited permissions as they can only rate a movie, tv show and
tv episode. Creating a guest session is as simple as calling the new guest session method.

- the first thing that we want to get are some images

IMAGES:
-movie, TV and person objects contain references to different file paths. In order to generate a fully working
image URL, you'll need 3 pieces of data. those are the base_url, a file_size and a file_path
- so we need the right image urls from movies that we want, so we have to try and find out how to get the
movies that we want.

MOVIES:
- so we make a get request to /movie/{movie.id} and apparently this supports something called Append to
Response.
- append_to_response is a query parameter and it makes it possible to make subrequests with the same namespace
in a single HTTP request. Each request will get appended to the response as a new JSON object.

- so now we have the image paths that we want but there are different sizes based on the screen length.
- for the small screen we just want w500 but for the larger screen we want to have the original size.
-so I need to figure out how that can be made possible. I assume we will have to do it with css perhaps
because what I want to do is to create responsive images.
- so the best practice is to have different copies of an image, each at a different resolution we should
be able to use responsive techniques to serve each users with the appropriate screen size.

SRCSET:
- the media queries solve the problem when images are invluded via CSS, but what about the <img> tags. for this
- we have to use a different approach, we use the srcset attribute, short for source set
- the source set attribute is a newer addition to HTML. it allows us to specify multiple image URLs for one
<img> tag and to specify the resolution for each. the browser will then figure out which image it needs and
download that one.
- to make sure that images don't overflow their container's width. make sure to set the max-width on the
img tag to 100%
-what should we do if an image is fixed size in pixels but we want to cater for screens of different
density
- if you don't specify the width and height of an image, the browser will display the image at its native
width/height
-in order for the browser to pick the right image, it needs to know

1) URLS for the image at various sizes
2) the decoded width of each of those resources
3) the width of the <img>


-ok well lets get atleast one image and see what it will look like, so I actualy think I can just create the
image slider with react springs

USETRANSITION:
-feed the animated transition group your items, keys (which can bee null if the items are atomic), and lifecycles
whenever itesm are added or removed, it will animate theses changes
- so we are defiantly going to use this for the transition effects.
- so the first thing that we are doing is create a list with useState. real quick lets go read up on useState.

USESTATE HOOK:
- what even is a hook. A hook is a special function that lets us 'hook into' React features. useState is
a hook tha tlets us add React state to functional components. so we add a hook when we want to add some state
to it.
- when we call useState it declares a "state variable". this is a ways to "preserve" some values between
the function calls. Normally variables "disappear" when the function exits but state variables are preserved
by react
- it returns a pair of values, the current state and a function that updated it.
- so basically useState is a hook in React and hooks let us hook into React features, useState lets us preserve
function state even after the function has been called. It returns two values, the current state and the
function to update that state. this is about how fast I can.
- there are also rules for hooks

RULES OF HOOKS:
-there are two rules that must be follow when using functions
1) only call hooks at the top level, do not call hooks inside loops, conditions or nested functions.by
following this rule, we ensure that Hooks are called in the same order each time a component renders, this is
what allows React to correctly presece the state of Hooks between multiple useSTate and useEffect calls

2)Only call hooks from React Functions.  do not call hooks from regular javascript functions.
- we can also call them from custom React hooks

-also when we use useState we are using array destructuring and that the names on the left are not part of the
React API. so that means that we can name them what ever we want
- the reason that we are able to name things whatever we want is because of array destructuring, it works on
the index of the array instead of the named properties.

- ok so now back to the useTransition

USETRANSITION:
- so the very first thing that we do is import {useTransition, animated} form 'react-spring'. once we have
those imported.
- second is we create some state with useState, make sure it is an array of objects with the image url
for our case and also an id
- now is where we use the useTransition to create the transition effect. we create a constant variable
and set it equal to
    useTransition(items,item=> item.key,{
              from:{transition:<effectHere>},
              enter:{transform:<effectHere>},
              leave:{transform:<effectHere>}
    })

- in this the items will be what we set our state values name to be with useState, the item is refering to
the item on the current rotation of the loop, think like how map or forEach works. the item.key is the key for
the current item. the real animations occur in the object properties called from,enter and leave.
-we put the animations that we want to take place in there, in our case it would be opacity

- then we return the transitions and it appears to work just like map would.

    transition.map(({item,props.key})=>{
    <animated.div key={key} style={props}>{item.text}</animated.div>
    })

- so clearly we messed up somewhere because it is just rendering and not animating like it should
- so there is definetly some extra javascript and index stuff going on that the spring team is not telling me about.
- yep so definetly something extra that is going on with an index value to make sure that we only render one value.
- but I can use this single image to practice some moving stuff. ok so lets start playing around with the css
in order to get some cool stuff going.
- so right now I am just messing around with stuff. I should read a blog post or two and then try to play around.
- so lets try to make the smooth image slider that is on the page

- so what does transfor3d do?
it is a function that repositions an element in 3d space

-ok that image slider was actually pretty easy and looks pretty dope.
- now lets just try to make useEffect to up the index, after every index, increase it should wait 5 seconds and then
fire again

- so the props that is added in the transitions.map(({item,props,key})), the props is coming from the
transition variable that we defined earlier. I think that it is destructuring them. destructuring allows us
to pull multiple pieces of data from an array or object and assign them to their own variables
- in react we can destructure props. ya so we are definitely destructuring the props and pulling out the
item(current item), props(current style), and the key(the id that we specified earlier).

- A React components lifecycle contains distinct phases for creation and deletion. these are called mounting and
unmounting.  this is what is called "setup" and 'cleanup'


MOUNTING:
-in the mounting(DOM creation, or "setup") phase, we have access to two lifecycle methods. componentWillMount
and componentDidMount. componentWillMount is now depreciated
- componentDidMount is called only once, but immediately after the render() method has taken place. This is
the method that is used to grab information from an outside source, just like useEffect.

UNMOUNTING:
- this is the deletion or cleanup phase, we can have just one lifecycle method to help us out: componentWillUnmount

- so useEffect takes place of componentDidMount and componentWillUnmount
- hooks let us Hook into react features like lifecycle methods
- so if we don't put the dependency array, then it will be called every rerender of the component, if we give
it an empty array, then it will run only on the first mounting of the component
-so I think my effect would need a cleanup
- so the useEffect is used to mock the componentDidMount and componentWillUnmount, so I should read up on those

- so a component is invoked immediately before a component is unmounted and destroyed. Perform any necessary
cleanup in this method like invalidating timers, canceling network requests, or cleaning up any
subscriptions.
- so I think I need to read up on how setInterval works and how the division worked on this one.

SET-INTERVAL:
-inside the React component allows us to execute a function or some code at specific intervals.
- so the standard thing looks like we create a constant variable and call it interval and then set the
interval to the setInterval function. After that we call clearInterva(interval) and this will clear up the
event
- so the way that we stop an interval is by calling clearInterval()
- we combind this with the empty dependency array, meaning that the interval is correctly cleared and
no longer triggers every second after the component unmounts from the DOM
- ours works thanks to the % operator. lets read up on that a bit. then we should see if we can get the
image slider to get info from the api instead of just these pre set images.

THE % OPERATOR:
- this is called the modulus operator and it is used to return the remainder of the division. we use
it like this.
                const interval = setInterval(()=>{
                  setIndex((index)=>(index +1)% images.length)
                })

- the use of the module operator is what gives us the ability to do this without the if statements that I
was using before.
- then after we have that we call the cleanInterval(interval). calling this function means that we don't have
to worry about memory leaks.
- so lets make a call to api to get movies at are now playing.
- so i guess I really do have to read up on Api calls about react
- ok I think we should lay off of the dynamic images
- we should work on the scrolling slides next

CREATING THE IMAGE SCROLLER:
-So I think what has to happen is that we are going to have the image slider on one side layed out across the
screen and then have the overflow-X set to display none, so we are going to need a card, that card is going
to need its own state about the title and everything, possibly the stuff for rating and what not.
- so we are going to need a single compoennt for getting the images, lets call image scroller and then we want
to get the data from the api then map over it and have the images each have there own state.
- so lets get the images with an ap call first
- are functional components in strict mode like Es6 classes?
- so I dont think that they are because they are function just function expressions and function expressions
are not called in strict mode. But that did lead me to something called strict mode in React. It seems
like something that is worth exploring after this app is made.
- so my width is not working and I guess it has soethign to so with the fact that display width changes
the way that width work.
- for determining the size of a flex item the final flex-basis bound by min-width and max-width is all that
matters. so min-width and max-width is all that matters.
- so I fixed the problem by taking off the parent elements width of 100%. I need to read more about width in
order to understand it better. Min width and max-width are saying that at most it will be something
and at least it will be something else
- when we are using % for widths, the precentage is based ont he element's parent, or in other words, the
width of containing block
-box-sizing: border-box lets us avoid many problems inherit in using width 100%. the border-box makes sure
that padding is factored into the width of our elements.
- a block element by default will expand by defualt to fit the width of its containing or parent element. minus
any margin or padding.
- when you give an element a width of 100% in CSS, your basically saying "make this element's content area
exactly equal to the explicitly width of its parent but only if the parent has an explicit width"
- so on our image slider container we have a width set to 100%, then inside of that we have a div called
image-scroller-container and we don't have to set the div to 100%  because block level elements are
- so if no width is set, it will naturally to fill its parent container and can have margins and/or padding
- if no height is set on a div element, it will expand naturally to fit its child elements , so it
is not necessary to give it a set width or to give it a width of 100%, if you want to fill its parent
horizontally. In fact, doing either of those things may cause maintainability issues or other undesirable
problems.
-so our divs must automatically expand to fit the width of their parent elements. interesting and that
width of 100% can cause some wierd issues, lets start to see how we want out cards to look.
- so right now I want to make a progression bar for the amount of
- so now I have to think a little more abstractly and we are just going to delete the image slider all together.


- so lets try to add some kind of growing animation to it.
- ya we are definetly to to use useSpring because we are going to have it toggle to some state.

- we know that we have to import animated and useSpring but what else do we have to do.
- so we can either overwrite the values or change the animation. we are going to go with the toggle of the properties,
I think if we set the height and width to 0 then we should be able to get a growing animation from it.
- so the animation is being a little weird on me, might be some kind of event bubbling. So I will not be implementing
that right now.
- now I am going to implement the ref to close the documents and then work on the authentication

AUTHENTICATION:
- authentication is outlined in these steps
1) create a new request token
2) get the user to authorize the request token
3) Create a new session id with authorized request token.

step one:
- the first step is to create a request new token. This is a temporary token that is required to ask the user
for permission to access their account. this token will auto expire after 60 minutes if it is not used
- so its a simple get request to /authentication/token/new

- the basics to getting a user authenticated look like this.
1) create a new request token
2) Get the user to authorize the request token
3) create a new session id with the authorized request token

- so it all starts with getting a request token. so how do we do that

1) GETTING THE REQUEST TOKEN.
- this is literally just making a get request to /authentication/token/new and on the respone there will be a request token
-ok so we got that

2) ASKING THE USER FOR PERMISSION
- so this also seems pretty simple just have to redirect the user to page on the movie DB site and it will do the
authentication for us.

3) CREATING A SESSION ID
-then we call a new session method with the request token that had been approved by the user in step 2 we will return
a new session_id. This is the session that can now be used to write user data. You should treat this key like a
password and keep it secret.
-calling a session method just means making a post request to /authentication/session/new
- that can be used to create a fully valid session id.
- we need to send it an api key and the authenticated request token in the request boby.

- so thw whole thing seems pretty straight forward and  a lot simpler than what I had expected. first we make a
request for a request token. then we redirect the user to loging on the movieDB site, then now have an approved
request token and this token can now be used to create a session id. that is make by making a post request to
/authenticate/session/new. in the request we send the api_key as a query string and the request token in the
request body. the response is a string called the session_id.

- so my biggest concern is how and where do I store all of these session_id and request token, do I just store them
inside of react or use the client side storage, not 100% sure. I guess I will have to do some reasearch.

                                CLIENT SIDE STORAGE

COOKIES:
- cookies are the earliest form of client-side storage commonly used on the web. the large number of security
problems and its inability to store complex data make it unsuitable for use today

WEB STORAGE API:
- the two main web storage types contained within two structures inside the browser: local storage and session storage.
- local storage persits data still after the browser is closed and then reopened, and the second one persists data while
the browser is closed and the second one persists while the browser is open

SECRET KEYS IN REACT:
- so if we want actual keys to be served, but to remain hidden with client code, that can't happen. you can't hide
anything that you give to the client. we will need to use something like JWT where the server controls the means
of authentication. Ok, so maybe I should be using JSON web tokens

- JWT is for authorization, not authentication. authentication is when you are taking in a password and username, to make
sure that the username and password is correct. this is what is done when a user is logged in.
-authorization is making sure that the user that is logged in is the same user that is making the requests. it is
authorizing that this user has access to this kind of authentication

- so looks like the server creates a JSON web token when the user logs in. the user will log in by making a post to
a server. the server will then do the authentication to make sure that the user is correct.
-ok  so ya I wont be creating a JWT, the session id is what the server creates and then gives to us to authorize
the user on what he needs to use.
- so I think that I am just going to store the value in React for right now.
- so I need a login in link that will send a get request to get the new_token. then a login button on that will
redirect the user to login with movie db and then ot return the session id that we will use to create post
requests on behalf of the user. That should not be too hard.
- so lets go over the steps again.

1) first we create the request token by making a get request to /authentication/token/new
- the response that we want is the request_token

2) get the user to authorize
- this is when we have to redirect the user to the login page on movieDB. the url will have the request token in it
- the request token that has been used is now been approved and can be used to create a session id

3) create a session id
- to create a session id we need to call a session method. the session method is just a post request to
/authenticate/session/new. it will return a session_id and we will use that to allow our app to make requests
on behalf of the user

- now I have a clear picture of that to do
-so we want to make a login page that automatically sends a request to get a request token once the page loads.
- so we have the token we now have to redirect the user to login page on the MovieDB site. I want to read up on
how this works exactly.
 actually we are probably going to want to raise that state up quite a bit so we can do things with it
 -ya so we are going to want to make the session id global state
 - so I think that we are going to have to raise the state and then when we get the request back we are going to update
 the state and have that state then call the session method.
 - lets read about useReducer to see if it can help at all.

 UseReducer:
 - it is an alternative to useState. Accepts a reducer of type (state,action) => newState, and returns the current
 state paired with a dispatch method.
 - useReducer is usually-preferable to useState when you have complex state logic that involves multiple sub-values
 or when the next state depends on the previous one. useReducer also lets us optimize performace for components that
 trigger deep updates because you can dispatch down instead of callbacks. so when we have deep prop drilling or
 we have to send props data up to the parent we should think about using useReducer but for right now, we do not
 need to use it.

-so I guess for right now we should have some callbacks
- well first lets figure out how to redirect the user once they click login with MovieDB
- I think it is called programmatic navigation

- so looks like we can use the redirect component, the blog post says that this is the recommended way to navigate
other than the <Link>

REDIRECT COMPONENT:
- the easiest way to redirect to a new location is y usig its redirect component. When the component is rendered
the existsing location of the history object is replaces with a new location. if you don't want to override
the existing history location, including the push property will push a new entry onto the history
- the easiest way is to use the Redirect component. when this component is rendered, the history object is replaced
with a new location.
- so we are going to import redirect and we are going to have the redirect component to be inside of our condional
rendering
- so an external link with react Router does not work, it just creates a memory leak, so I need to find something else
to try.

REDIRECTING TO AN EXTERNAL URL WITHIN REACT-ROUTER-DOM:
-to do this at the route level we simply need to render a function assigning the window.location to the new site
and then the user is redirected.
- damn so looks like I am going to be doing some big boy prop drilling
- Rendering a redirect component will navagate to a new location. The new location will override the current
history object. like server-side renders.
- server side rendering, sends a fully rendered page to the client.
- the history object is used for navigation.
-the issue is that redirect is for internal links only.
-----------------------
- what we want is to use a component that uses window.location to force the browser to go to another page
- so we want to create an inline component that uses the window.location to tell us where to redirect.
-so we have to get the access token, authorize it and then call the session method with it and use the session_key
that is returned to make the post requests.
- so we are going to need the request token and the session_key to be stored on the frontend.
---------------------

-using local storage in functional components is a side effect which is best implemented with the useEffect hook
- so in the use Effect hook would go, localStorage.setItem('myvalue',value) in our case the value is going to be
the request token. this is to store the item, now we need to retrieve it.
- to retrieve it we can set the value to a constant using use state
          localStorage.getItem('myvalue') || ''

- this should get our value if there is one and if there is not then we just set the value to an empty string
- that was localStorage which persists data for longer we want. we want data just for the page being open
-session storage is used the same way as cache storage
- we could also use this storage to save the data of a search if you search for something multiple times. We can
worry about cahcing later, for now lets just try to get the the user token and make a session key.
- this whole redirect thing has been for not because I literally just could of used the fricken Link component

- ok so I have the login working. Now I have to get the session_key working
- so it looks if the page from step 2 is redirected with a custom url it will have a authentication-callback
header that can be used for step 2

AUTHENTICATION VS AUTHORIZATION:
-authentication means that we only want to identify the user who's trying to log into an application. It's a
way of identifying the users to make sure they are who they are claming to be
- so authentication is just checking to see if the user can log in or not, when we see authentication think user login
-authorization is checking to see if a user is authorized to do something like a post request to a server. this
is the part that I am having trouble with. the ability to check if someone is allowed to do something
- we should have a token or something during the authentication process
- so everytime the homepage loads I want to make a post request to the movidb to create a session token

- so I found the authentication/token/validate_with_login and it will allow me to validate the login with
a login page on my app
- so right now I get to create a form with some validation and all the typical form jazz.
- there was also the snazzy form validation tutorial on you tube that I could try to watch again.
- ok  but first lets try to create it ourself.
- so the first thing that we are going to do is create a controlled form with 'controlled' inputs.

CREATING THE CONTROLLED FORM:
- when I am going setValues({...values}) I am saying that I want react to put all the values in the object as single
properties. I am saying that we should 'spread' them into the object with the spread operator.
- then I am going to replace the values

- creating the controlled component is pretty straight forward, all we have to do is create a form and then have the
inputs have their on change value to be set to the react state values, this is what creates the 'controlled' component
- the next thing that we are going to create is a custom react hook, this will allow us to abstract the validation
and make it so we can use it for other things
- the important thing to remember when creating a custom hook, is that we have to return an interface of whatever values
are needed, in this case it is going to be the handleChange,handleSubmit,values and errors
- another important thing to remember is that you have to also import the custom hook and then destructor
the values that come from the importing and running for the custom hook.
- now we have to deal with the errors, we need to have a state that deals with errors, we need to have a
function that can validate and return errors and we need to pass these errors back to the form
- to validate the errors we will create a new file that checks if everything is valid or not. all we
want to check is that the username and password values are not empty
- ok so now let go through how this submitting phase starts and ends

ISSUBMITTING PHASE.
 - this is the phase where we would do the api call or actually submit the function. this is the cleanest
 section of all the code.
 -so the first thing that we do is create a state called isSubmitting and we set the initial value to false
 - we set this value to true in the onSubmit function after we set the setErrors with the validate function
 - then we implement useEffect. put the errors state in the decency array to say that we want to run useEffect
 whenever the errors state changes.
 - inside the useEffect we want our api call to happen when ever the errors object is empty and the isSubmitting
 is true. to check if an object is empty(error object) we can do Object.keys(errors).length === 0 if that
 is true and if isSubmitting is set to true then

 so what the heck is going on in our form?
 - so the first thing that we are doing is make the form controlled, this means making all the input values
 'report' to a 'single source of truth'. then we can create the custom Hook that will deal with the
 validation.
 - in the custom Hook we will deal with the states of the values from our inputs and the state of the errors,
 also the handleSubmit and the handleChange function. so inside this custom Hook function (useForm) we will
 return values,errors,handleChange and handleSubmit.
 - once we have the handleChange funciton set up and it is able to update and store the proper values, we can
 set up the errors, the errors have their own state called errors.
 - the actual validation will happen in another file called validate, this is where we can actually do the
 validation on the values.
 - the first thing that we should do in this function is to create an errors object and return it.
 more about this later
 - the function that will be doing the checking is called validate and it will accept one parameter called
 values. this will be the values of the inputs that we pass it
 - it will then use values.username and values.password to run checks on them. for this app we are only going
 to make sure that they are not blank.
 - if either of the values are blank then we want to update the errors object with error.username ='Required'
 and or error.password = 'Required'.
 -we will return the error object whether it is empty or not.
 -the validate function will be called by the setErrors(validate(values)) this will update the errors state
 - after setErrors is called in the onSubmit() function we need to call isSubmitting
 - isSubmitting is a state that we are going to set up with the help of useState and initilize its value to
 false. this value will come into play later with useEffect()
 -so in the onSubmit() function we have called the setErrors(validate(values)) to get the errors and then directly
 after that we are going to call setIsSubmitting(true)
 - the last part that we are going to do is to create an useEffect() hook and we are going to give it the errors
 state in the dependency array [] so that the function only runs when the error state changes.
 - inside of useEffect() we want to check if the errors state is empty and that isSubmitting is true, if it
 is then we can run our api call. so to check if the errors object is empty we are going to do
      Object.key(errors).length ===0 && isSubmitting
 - above checks to make sure that there are no errors and then isSubmitting is set to true. if it is then we
 can run the api call, if it isnt then nothing and errors should be shown to the user
 - so in our hook we have to make sure that we return values, errors, handleChange and handleSubmit. On the
 component page we are going to have to deconstruct all of those things and make sure that they go in the
 right spots.values should be with the values on the inputs, errors where ever you want to show them and
 handleChange on the inputs and handleSubmit on the form.

 CREATING THE FORM AND VALIDATION ALL BY MYSELF:
 part 1 controlled component:
 - first thing is to create the form a controlled component.
 - when we are setting the state for the values hook , we have to remember to use the spread operator to
 make sure that all the previous values of that state get individually merged in because React does not automatically
 merge things, instead it overwrites them, so if we do not use the ES6 spread operator(...) our previous states
 will get overriden(no bueno)
- when setting the values state make sure that you go [name]:value. otherwise javascript will just think name an
identifier and will set the name as the key and not the value of name.

part 2 custom hook:
- so now that we have the controlled component we are going to create a custom hook, to abstract some logic away and
make things cleaner.
- create a file called useForm. Inside that file create a function called useForm. make sure that use is the first
word, this is how we can identify a hook and lets us see that the law of hooks applies.
-in this function the logic we are going to abstract away is the values, onChange and onSubmit.
- make sure that we return values,onSubmit and onChange.
- then import the useForm hook into the component file and destructure the values that were returned by that function
- now we can create the error state, this will be used once we create the acutal funciton that does the validating
- the errors state can look exactly like the values state, make sure that it also gets returned

part 3 validation:
- this is the part that does the validating is done.
- we will create another file and call it validate.js, in this side we will create a function called validate.
- in this function we will create an object literal called errors and make sure that this is the only thing that
is returned from this function.
- the function will also take one parameter and that will be the values from the useForm hook.
-for validating we are just going to  make sure that it is not empty. we just make sure the password and username
are not empty, so values.password and values.password.
-if the value is empty then we set the error object with that value and then return it

part 4 is submitting:
- this is the part that were we would actually do the api calling.
- first we create a state called isSubmitting and set the initial value to false.
- then after we use setErrors in our onSubmit function we are going to call setIsSubmitting(true)
- then we are going to use the useEffect function. create the useEffect function and make sure it has the errors state
in the dependency array. this means that useEffect will only run when the errors object changes.

        Object.keys(errors).length === 0 && isSubmitting{
          <make api call />
        }

-this will only run if there are no values in the error object and that isSubmitting is set to true
- now that is is complete it is time to add a little style.
- so now I need to make an api post request. with a request token, user name and password in the request body

- I really need to read up on useEffect and what it actually is doing.

useEffect:
- so the dependency array means that the useEffect array should run only after a any of the values in the array
changes. lets test that out. so ya, if you put something in the decency array, the useEffect is going to run after every
time something in that array is updated.
- so I should really start to think about code reuseability from now on and how I can make things more general and
abstract the more specific stuff away, think like Legos.
- proper conditional rendering
- ok so now that we are able to log in and get the request token authenticated, we have to make the session call, I think
this is what was giving me trouble last time, so lets hope that this time it is better.
- still having troule with the session calls but I will set something up in react fist to test it to make sure that everything
if it is me or what

MAKING THE REQUEST CALL ON THE HOME PAGE:
-The so when the page loads I want it to make a request with the request_token that is in the session storage and I only want
it to run once, when the component loads so I will give the useEffect hook an empty dependency array.
- then depending on the response we want the modals to respond in kind. if it is a valid response the modals should allow us to
rate and do whatever to the movie that we have selected. All that will be more post requests. if the response is invalid,
we want the modals to refer the user to log in.

- well maybe for now we can just make a guest session
- so making a guest session, is pretty easy, we make a call and then get back a guest session id, I assume that this id
is what we are going to use for the post requests to rate movies.
- now That I know how easy the authententication is, I think I am just going to delete the separate login page and just have a modal
that does the same thing...

- right now I want to make a search bar that will let us search whatever we type in, an sense we get unlimited requets, I am going
to make it real time.
- ok so lets look into creating the animation for the log in.
- actualy I think that the Modal should be its own component. That would make the most sense.

CREATING AGAIN WITH useSpring:
-so the first thing is what we alread, know we have to import useSpring and animated
- the next part is where we have choice we can choose from two methods to trigger the animation. the first method is to trigger
an animation by a change of state, the second is to use a function. we are going to use the first one.
- so when the state changes, that is when our animation is going to happen.
- we are going to set the possible first and get it in line.
- so I guess I am rewritting the whole mobile nav bar to useSpring animations.
- first we need to import and then we need to create the props to be animatated
- so the height and width bug that I have been dealing with only happens if you specify 0 as a number, to fix it just put
'0px' and that will work
- so maybe we jsut can't animate the margin, so lets try to animate using transform:translate

- so now that I have the NavBar working like I want. I can create the log in as guest page. I want the login modal to
be rendered in the home page because I want it to toggel a state that gets passed into each ImageScroller and have
the ImageScroller modal pop up act accordingly to that state.

-when the login button is clicked, I want it to toggel the state that is in the image scroller, that means I have to
lift the state up.
- so I think what we have happening is some event bubbling. Lets find out what event bubbling is.

EVENT PROPAGATION:
- Event propigation is an overacrching terms that includes 3 different phases of DOM Events: capturing, targeting and bubbling
- so event propagation includes, targeting,capturing and bubbling. it includes targeting, bubbling and capturing. the first
phase is capture, then targeting and the final phase is bubbling. the three phases of event progagation are captuing, targeting
and then bubbling. the first phases is capturing, the second is targeting and the last is bubbling.

event capturing phase:
- when an event occurs in the DOM, notification of the event is passed starting at the top of the DOM tree and passing down
through all parent element nodes all the way to the target node where the event occured. so basically. to capture the
target event a notification of the event is passed all the way down to the event node.

event target phase:
-this phase only includes a notification of Node where the event took place. this is just a notifiction of where the event
took place.

event bubbling phase:
-a notice os passed from the target Node all the way through the Parent node all the way back to the top root of the DOM

EVENT BUBBLING:
-this refers to the ability of evnet set on DOM nodes to 'bubble up' and also apply to ancestors nodes

- so I guess nothing wrong was actually happening I had just made them output the same thing.... oh,well.

- well I guess all of my extra notes got deleted...
- ok well on creating the star. I think we are going to have to go with the svg to create the star becasue
the font awesome  icon really isnt being that awesome right now. so now I will read up on svg iamges

SVG:
-so I guess a star can be created with a polygon inside of an svg state

- I went back and created the stars with the normal font awesome star icon and now It is working. Now I
just have to be able to use some animation to make the stars grow depending on the mouse position.

- so right now I am thinking that we have an onMouseEnter event on all of the unchecked stars and we want to
- increase the with of the check stars by 20 depending on what star we are on
- so onClick we want the width and the z-index to change.
- ok I think again I am going way off course with this code and it doesn't look like it is going to work like i want it to


CREATING THE STAR RATING SYSTEM:
-so my version was just trash and I could see alot of holes moving forward, so I have deleted it and I am now
creating one from a youtube video.
- the polygon stars that we have created are missing their left arm,we will have to look into that later
- we are going to need a state of not filled,filled and we also need a way to hold on to the rating
- we are going to need, useState and useEffect.
- so far we have mapped over the star array and created a star for each value, the key is the index from the
map method
- we have created a rating stae and a hover state to hold their respected rating values
- so onMouseEnter we want to set the hover index to the current value of the index, onMouseLeave we want
to set the index value to 0. we should be able to use the overIndex to set the color classes.

- so on mouse enter, we want to set the hoverState(index), this means that if we are on the fifth, star
then the hover index gets set to 5.
- then onMouseLeave we want to set the hoverState(0)
- we then have an onClick function that we pass to the star and this will be how we set the rating of the
star for us, it will also be where we make the api call.we will set the rating to be the same value as the
index
-finally we have a rating and this will be the rating that we are going to hold on to. we will call
setRating(hoverState || index)

- so for each individual star the hoverstate is initialy 0. when we hover over something, that state is then
going to be set to the current star index. onClick we are going to set the rating to the current index, 0-5
-initialy our star has a hover state of 0 and a rating of 0 but when we click we will set a rating to an
index value.
- we also pass the star a starId={i},

- ok so lets figure out what the heck is happening

part 1) getting set up:
1)we create the star component with the svg and the coresponding css to make it look somewhat nice,
2)export it and import it into the component that is going to use it.
3) create a constant called stars and set it equal to an array with 5 variables in it(# of vars depends on how many stars you want)
4) map over the stars constant and have it render a start component

part 2) the states:
1)create a state called hoverState. this will be used with onMouseEnter and onMouseLeave. onMouseEnter we will setHoverState(index)
and onMouseLeave(0). This means that when we hover over the a star, that hoverState will be set to the index,
the first star will have a hover state of 0 and the second star will have a hover state of 1. This will be
important for the rating later on

2)create a state called rating. This state sill hold the value of the ratings. this value will get set
when you click on the star, so onClick={setRating(index)}. this means that when we click on the star
we are going to set the rating to the value of the index. also, the rating value on the star will be set to
rating={hoverState || rating }. this means that the rating value on the star will evalate to the rating
over state is 0 and to the hoverstate otherwise. we will later use the rating to determine the class name
for the star.
- so the rating is always the hoverState until it gets clicked. that is also important for when choosing the
className.
3) create a property on the star component called starId. THis is going to be set to the index of the map()
-this is also important for determining the className.

part 3) getting the stars to change:
1) destructor all of the things that were passed into the star component. onMouseEnter,onMouseLeave,
onClick, rating,starId.

 part 4) set them all to there appropriate places.
-the onMouseEnter and leave are both put on the div containing
the star component. so everytime we hover over or leave it is going to set the over state.
-the onClick also gets set on the same container as the onMouse events. this onCLick event will set the
rating state.

part 5) setting the className:
- this is the most important part, this is what everything else was building up to. we are going to create.
- on the svg for the style prop we are going to set it equal to a variable called styleClass. this is what
is going to change and let us have the desired coloring.
-the last thing that we are going to do is the logic that will allow us to change the color of the stars
-we eill go
      if(rating >= starId){
        styleClass= 'star-rating-filled'
      }

  - this says that if the rating( the props that was set on the star component) is greater than or equal to
  the starId then change the styleClass to 'star-ratin-filled'. the rating will be greater than or equal
  to when we either hover over it, or when we click it


  - the hoverSTate is always changing but when we do not hover a star, the rating defaults back to the state
  called rating. THis rating state gets set when we click on it.


  -so now we have to create the api call that happens when we click something. Now I think is the time
  to use functional programming to try and abstract away the api calls into there own function

  - right so lets make 2 functions, one for the post request and one for the get request.
  -actually I think that I want to create my own hook. lets read up on that a bit.

  CUSTOM HOOKS:
  - custom hooks let us extract component logic into reusable functions
  - a custom Hook is a javaScript function whose name starts with 'use' and that may call other hooks
  - each call to the custom hook gets isolated state.

  - so I seem to have run into a problem when try to create my own custom hook, I think I will have to go back to the
  form validation video to see what is happening again.
  - my problem is that I can't call the hook from anywhere that is not a react hook or component

  what do we want returned from our custom hook:
  - so we need to return values from the form and then destructor those values out of the function in order
  to use them.
  - so what do we want to return from it ?
  - could return a function that makes the api call right?
  - so I guess a guest_session Id is required
  - so i keep getting the status message of sesource could not be found, I guess I could try and figure out what
  that means
  - So I guess I can now go into the seach component of it. SO I want a search bar that will load the movie that we
  have searched for, or the ones that loaded on load. So I guess it redirects us to a new page. that is kind
  of cool.
  -for first lets create a big old search bar

  CREATING THE VALIDATED FORM:
  1) turn the form into a controlled component

  2) abstract things away to make the form more generic.
  - this is where we are going to create a custom hook. In order to do this we have to pull out the onChange,
  onSubmit,the states and then errors
  - so we have created our own hook to abstract away all the generic form stuff, so we abstract away onChange,
  useState,onSubmit
  -well on submit we want it to check for errors. To make things more generic we want to abstract away the
  specific kind of validation to another file

  - now That we have that down, we can do some styling.


  Making the api call with useEffect
  - we want to make the api call and then redirect to a new page with the all the info
  - so I need to make sure that I have the right path
  -then I need to make sure that my api call hook works

  - so what is going to happen when I search for something?
  - lets follow the code.
  1) as we type in the search for the state caled values will be updated, if it updates that means that it is a controlled componen t
  and that it is working properly
  2) when we hit submit, the handleSubmit() function should fire off. it is going to console.log('submitted') and then run
  the setErrors(validation(values)) it will then update the errors state accordingly. it will also then setIsSubmitting(true)
  3) the useEffect hook will run to check if the errors state is empty, if it is then it will run the apicall function
  with the extension for the endpoint and the proper query. right now the useEffect hook will run any time the error or values
  function is updated. actualy it only runs when we submit somehting
  4) run the useAPI hook. Right now the useAPI will check to see if the second parameter is an object or a string. since it
  is a string it will run the get method. Once it has done that it will console.log() the outcome. so we should get an console.log()
  of just the data that is returned.

  - I think I want to make search a separate page. it actually shouldnt be that hard

  - so lets get the individual pictures rolling out and then we can worry about the filters. also, lets try
  to keep the css styling to a minimmum for right now. I want to read how I can better organize stuff
  - now that we have the search working we are now going to figure out how to get the individual button images
  to load. That is definitely a link to somewhere with a

  - so what does the dependency array do on useEffect again?
  - without a dependency array,effects run after every render and setting the state will trigger the effects
  again
  - effects always 'see' props and state from the render they were defined in.
  - whenever we update the state, React calls our component. Each render result sees its new state.

  -so now lets look at the react-dom-router and figure out how we ae going to get a link to the page
  that we want.

  ROUTE PARAMS:
  -route params are parts of the URL that will change based on the object we want to display. we
  can designate a dynamic portion of the URL to be matched by putting a colon(:) before it.
  - so lets create a component and the route that we want in the app index file
  - so now that we have the page we need to be able to grab what is in the url and make a request with it
  - inside the react-router-dom library the user is passed to a prop called 'match' and inside match ther is another
  prop called params . the params object will be holding the url parameters that we want

  WHAT IS JAVASCRIPT MISSING:
  - javascript is multi-paradignm language, meaning that it supports programming in many different styles. Other
  styles supported by Javascript include procedural(imperative) programming, object-oriented programing, where
  objects are the primary building black not functions and of course functional programming.
  - the disadvantage of a multi-paradigm language is that imperative and object-oriented programming tend to
  imply that almost everything needs to be mutable.

  HIGHER-ORDER COMPONENTS:
  -takes a component and returns a new component
  - in a large app, the same pattern so subscribing to dataSource will occur over and over again. We Want to
  abstract that allows us to define this logic in a single place and share it across many components. This is
  where higher-order components excel.
  - we can write a function that creates components and have it subscribe to an external data source. this
  function will accept as on of its arguments a child component that receives the subscribed data as a prop.
  - so in this example the component that gets put into the function gets the subsribed data as a prop
  - so for us we would have a function that makes a get api call and then have it pass the information to
  down to the component that we pass as a component.
  - so we would be creating a function that takes two arguments, the component as the first argument and the
  datasource as the second argument

  - so for us it would be still be just the component and then the apicall data  as the second argument, but it
  would just be the function we don't have to call it yet. the api call would get called inside the HOC and
  then we assign that to a state value and then that values gets passed back into the component as a prop
  - so the HOC just returns the compoennt that was passed in with the state data that was assigned
  -The HOC doesn't modify the input component, nor does it use inheritance to copy its behavior. Rather
  a HOC composes the original component by wrapping it in a container component. A HOC is a pure function with
  zero side-effects.
  - so I think the main benefit to this is that it creates better isolation and reusebility for things

  - so we would use a HOC is an advances technique in React for reusing component logic.
  -so maybe we can achieve the samething with a custom hook?

  CUSTOM HOOKS:
  - building your own Hooks lets you extract component logic into reuseable functions
  - creating a custom hook solves many of the same problems that HOC solve but without forcing us to add
  more components to the tree.
  - a custom hook is Javascript function whose name starts with 'use' and that may call other hooks
  - so the main idea of our hook would be to make an api call and then we would want it to return the data
  that it made the call with
  - so we create a function and inside of it we have the useEffect hook and inside that hook we would
  want to call the api call with axios

  -ok so are definetly going to use a custom hook for the api call then.
  - stateless functions = functions that given the same input return the same output.
-I think I should make my hooks simpler and break them down into two different hooks for the api calls.
- also every custom hook has the useEffect make the actual call that allows it to do what ever. I guess
this makes sense, then we just have to call the hook to get the data. OK I can beleive that. I still want
to read more on useEffect to get a better grasp on it.

USE EFFECT:
- lets us perform side effects in functional components
- when we use the useEffect hook, we are telling react that we want to do something after render.
- by default useEffect runs after every update. so when we see use effect we should say after render run
useEffect.

- so now I want to create a slider component that will have the case and will slide based on current cast members
- so first we are going to create a component that create a slide for each cast member
- so we only want to make a cast slider for the first 8 and then we want to have a button to be able to view more
- so we should look at array functions other than map in order to do this.
