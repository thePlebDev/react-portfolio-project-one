
SASS:
- uses the file extension .scss. With a few small exceptions, it's a superset of CSS, which means essentially all valid
CSS is valid SCSS

- nesting rules are super helpful but the deeper the nest the more bandwidth we are using to serve the CSS and the more work
it takes the browser to render it. it is important to keep the selectors shallow
- browsers do not understand Sass, or any other css preprocessors. In order to be able to use Sass in the code. we need
something to turn Sass code into CSS code so that the browser can understand it. One tool that compiles our Sass is Webpack
- you can define variables that cen be peppered across multiple css files

VARIABLES:
- variables can hold a variety of data types.
- variables are defined by a $ immediately preceding the name of the variable and a colon separating the name of the
variable from the value.

    $main-color: blue;

- that is how you define a variable. then we can use it by just adding it to whatever we want like we would normally do in
CSS


- nesting can have a strain on your bandwidth and the specificity. Try to avoid overly using nesting


CSS STYLE CONFLICTS:
- there are 3 things when styles conflict.
1) the stylesheet origin:where the style sheel is coming from
2)selector specificity
3) source order

-user agent style sheets are the styles that the browser applies, they have lower priority, so our styles override them.
- the inline styles will override any declaration applied from our stylesheet.
- don't use IDs in the selector, they ratchet up the specificity a lot.
- don't use !important, this makes the specificity highest it can be and we will have to keep using !import whenever we want
to change something on that elemnent.

- then we are going to use  transition to make the image slider.


RESPONSIVE IMAGES:
- in responsive design, images need special attention, to make sure that they fit on the screen and to
consider the bandwidth of mobile users. when using images, we should make sure that they are well
compressed. User a tool for that.

- the best practice is to create a few copies of an image, each at a different resolution.

EMS AND REMS:
- ems, are the most common relative length unit, are a measure used in typography, refering to a
specified font size. in CSS, 1 em means the font size of the current element; so the em relies on the
size of the element that it is being placed on


REACT SPRING USESPRING:
- so we are going to go the re-render the component with changed props. this is where we set a props variable to the an
object that is set the useSpring() method

CREATING THE NAVBAR CLICK DETECTION:
-so we know what we are going to use the a dom ref, that is for sure.
- we are going to add a useEffect hook to add the click event to the document and we are also going to
make sure that useEffect returns a function so that it cleans up the function. we have to return a function
when it is a click that requires a clean up, this makes sure that we don't get a memory leak.

EFFECTS WITH CLEANUP:
- some effects require a cleanup like setting up a subscription to some external datasource. it is important
to clean up so that we don't introduce a memory leak.
- so if useEffect returns a function react will run it when it is time to clean up.

-an update can be caused by changes to props or state.

- we are going to use the useRef to get the hook value.
- so now we are working on the API.

API AUTHENTICATIONS:
-the application level authentication on this is controleld by either a single query parameter, api_key,
or by using the v4 access token as a Bearer token.
-for our applications authentication we are going to use the api_key authenticaiton

- an API read access token is expected to be sent along as a Authorization header
- user authentication is controlled with a session_id query parameter. you can generate a session_id
by following these steps
1) create a new request token
2) get the user to authorize the request token
3) Create a new session id with the authorized request token

- there are also guest sessions. they just have limited permissions as they can only rate a movie, tv show and
tv episode. Creating a guest session is as simple as calling the new guest session method.

- the first thing that we want to get are some images

IMAGES:
-movie, TV and person objects contain references to different file paths. In order to generate a fully working
image URL, you'll need 3 pieces of data. those are the base_url, a file_size and a file_path
- so we need the right image urls from movies that we want, so we have to try and find out how to get the
movies that we want.

MOVIES:
- so we make a get request to /movie/{movie.id} and apparently this supports something called Append to
Response.
- append_to_response is a query parameter and it makes it possible to make subrequests with the same namespace
in a single HTTP request. Each request will get appended to the response as a new JSON object.

- so now we have the image paths that we want but there are different sizes based on the screen length.
- for the small screen we just want w500 but for the larger screen we want to have the original size.
-so I need to figure out how that can be made possible. I assume we will have to do it with css perhaps
because what I want to do is to create responsive images.
- so the best practice is to have different copies of an image, each at a different resolution we should
be able to use responsive techniques to serve each users with the appropriate screen size.

SRCSET:
- the media queries solve the problem when images are invluded via CSS, but what about the <img> tags. for this
- we have to use a different approach, we use the srcset attribute, short for source set
- the source set attribute is a newer addition to HTML. it allows us to specify multiple image URLs for one
<img> tag and to specify the resolution for each. the browser will then figure out which image it needs and
download that one.
- to make sure that images don't overflow their container's width. make sure to set the max-width on the
img tag to 100%
-what should we do if an image is fixed size in pixels but we want to cater for screens of different
density
- if you don't specify the width and height of an image, the browser will display the image at its native
width/height
-in order for the browser to pick the right image, it needs to know

1) URLS for the image at various sizes
2) the decoded width of each of those resources
3) the width of the <img>


-ok well lets get atleast one image and see what it will look like, so I actualy think I can just create the
image slider with react springs

USETRANSITION:
-feed the animated transition group your items, keys (which can bee null if the items are atomic), and lifecycles
whenever itesm are added or removed, it will animate theses changes
- so we are defiantly going to use this for the transition effects.
- so the first thing that we are doing is create a list with useState. real quick lets go read up on useState.

USESTATE HOOK:
- what even is a hook. A hook is a special function that lets us 'hook into' React features. useState is
a hook tha tlets us add React state to functional components. so we add a hook when we want to add some state
to it.
- when we call useState it declares a "state variable". this is a ways to "preserve" some values between
the function calls. Normally variables "disappear" when the function exits but state variables are preserved
by react
- it returns a pair of values, the current state and a function that updated it.
- so basically useState is a hook in React and hooks let us hook into React features, useState lets us preserve
function state even after the function has been called. It returns two values, the current state and the
function to update that state. this is about how fast I can.
- there are also rules for hooks

RULES OF HOOKS:
-there are two rules that must be follow when using functions
1) only call hooks at the top level, do not call hooks inside loops, conditions or nested functions.by
following this rule, we ensure that Hooks are called in the same order each time a component renders, this is
what allows React to correctly presece the state of Hooks between multiple useSTate and useEffect calls

2)Only call hooks from React Functions.  do not call hooks from regular javascript functions.
- we can also call them from custom React hooks

-also when we use useState we are using array destructuring and that the names on the left are not part of the
React API. so that means that we can name them what ever we want
- the reason that we are able to name things whatever we want is because of array destructuring, it works on
the index of the array instead of the named properties.

- ok so now back to the useTransition

USETRANSITION:
- so the very first thing that we do is import {useTransition, animated} form 'react-spring'. once we have
those imported.
- second is we create some state with useState, make sure it is an array of objects with the image url
for our case and also an id
- now is where we use the useTransition to create the transition effect. we create a constant variable
and set it equal to
    useTransition(items,item=> item.key,{
              from:{transition:<effectHere>},
              enter:{transform:<effectHere>},
              leave:{transform:<effectHere>}
    })

- in this the items will be what we set our state values name to be with useState, the item is refering to
the item on the current rotation of the loop, think like how map or forEach works. the item.key is the key for
the current item. the real animations occur in the object properties called from,enter and leave.
-we put the animations that we want to take place in there, in our case it would be opacity

- then we return the transitions and it appears to work just like map would.

    transition.map(({item,props.key})=>{
    <animated.div key={key} style={props}>{item.text}</animated.div>
    })

- so clearly we messed up somewhere because it is just rendering and not animating like it should
- so there is definetly some extra javascript and index stuff going on that the spring team is not telling me about.
- yep so definetly something extra that is going on with an index value to make sure that we only render one value.
- but I can use this single image to practice some moving stuff. ok so lets start playing around with the css
in order to get some cool stuff going.
- so right now I am just messing around with stuff. I should read a blog post or two and then try to play around.
- so lets try to make the smooth image slider that is on the page

- so what does transfor3d do?
it is a function that repositions an element in 3d space

-ok that image slider was actually pretty easy and looks pretty dope.
- now lets just try to make useEffect to up the index, after every index, increase it should wait 5 seconds and then
fire again

- so the props that is added in the transitions.map(({item,props,key})), the props is coming from the
transition variable that we defined earlier. I think that it is destructuring them. destructuring allows us
to pull multiple pieces of data from an array or object and assign them to their own variables
- in react we can destructure props. ya so we are definitely destructuring the props and pulling out the
item(current item), props(current style), and the key(the id that we specified earlier).

- A React components lifecycle contains distinct phases for creation and deletion. these are called mounting and
unmounting.  this is what is called "setup" and 'cleanup'


MOUNTING:
-in the mounting(DOM creation, or "setup") phase, we have access to two lifecycle methods. componentWillMount
and componentDidMount. componentWillMount is now depreciated
- componentDidMount is called only once, but immediately after the render() method has taken place. This is
the method that is used to grab information from an outside source, just like useEffect.

UNMOUNTING:
- this is the deletion or cleanup phase, we can have just one lifecycle method to help us out: componentWillUnmount

- so useEffect takes place of componentDidMount and componentWillUnmount
- hooks let us Hook into react features like lifecycle methods
- so if we don't put the dependency array, then it will be called every rerender of the component, if we give
it an empty array, then it will run only on the first mounting of the component
-so I think my effect would need a cleanup
- so the useEffect is used to mock the componentDidMount and componentWillUnmount, so I should read up on those

- so a component is invoked immediately before a component is unmounted and destroyed. Perform any necessary
cleanup in this method like invalidating timers, canceling network requests, or cleaning up any
subscriptions.
- so I think I need to read up on how setInterval works and how the division worked on this one.

SET-INTERVAL:
-inside the React component allows us to execute a function or some code at specific intervals.
- so the standard thing looks like we create a constant variable and call it interval and then set the
interval to the setInterval function. After that we call clearInterva(interval) and this will clear up the
event
- so the way that we stop an interval is by calling clearInterval()
- we combind this with the empty dependency array, meaning that the interval is correctly cleared and
no longer triggers every second after the component unmounts from the DOM
- ours works thanks to the % operator. lets read up on that a bit. then we should see if we can get the
image slider to get info from the api instead of just these pre set images.

THE % OPERATOR:
- this is called the modulus operator and it is used to return the remainder of the division. we use
it like this.
                const interval = setInterval(()=>{
                  setIndex((index)=>(index +1)% images.length)
                })

- the use of the module operator is what gives us the ability to do this without the if statements that I
was using before.
- then after we have that we call the cleanInterval(interval). calling this function means that we don't have
to worry about memory leaks.
- so lets make a call to api to get movies at are now playing.
- so i guess I really do have to read up on Api calls about react
- ok I think we should lay off of the dynamic images
- we should work on the scrolling slides next

CREATING THE IMAGE SCROLLER:
-So I think what has to happen is that we are going to have the image slider on one side layed out across the
screen and then have the overflow-X set to display none, so we are going to need a card, that card is going
to need its own state about the title and everything, possibly the stuff for rating and what not.
- so we are going to need a single compoennt for getting the images, lets call image scroller and then we want
to get the data from the api then map over it and have the images each have there own state.
- so lets get the images with an ap call first
- are functional components in strict mode like Es6 classes?
- so I dont think that they are because they are function just function expressions and function expressions
are not called in strict mode. But that did lead me to something called strict mode in React. It seems
like something that is worth exploring after this app is made.
- so my width is not working and I guess it has soethign to so with the fact that display width changes
the way that width work.
- for determining the size of a flex item the final flex-basis bound by min-width and max-width is all that
matters. so min-width and max-width is all that matters.
- so I fixed the problem by taking off the parent elements width of 100%. I need to read more about width in
order to understand it better. Min width and max-width are saying that at most it will be something
and at least it will be something else
- when we are using % for widths, the precentage is based ont he element's parent, or in other words, the
width of containing block
-box-sizing: border-box lets us avoid many problems inherit in using width 100%. the border-box makes sure
that padding is factored into the width of our elements.
- a block element by default will expand by defualt to fit the width of its containing or parent element. minus
any margin or padding.
- when you give an element a width of 100% in CSS, your basically saying "make this element's content area
exactly equal to the explicitly width of its parent but only if the parent has an explicit width"
- so on our image slider container we have a width set to 100%, then inside of that we have a div called
image-scroller-container and we don't have to set the div to 100%  because block level elements are
- so if no width is set, it will naturally to fill its parent container and can have margins and/or padding
- if no height is set on a div element, it will expand naturally to fit its child elements , so it
is not necessary to give it a set width or to give it a width of 100%, if you want to fill its parent
horizontally. In fact, doing either of those things may cause maintainability issues or other undesirable
problems.
-so our divs must automatically expand to fit the width of their parent elements. interesting and that
width of 100% can cause some wierd issues, lets start to see how we want out cards to look.
- so right now I want to make a progression bar for the amount of
- so now I have to think a little more abstractly and we are just going to delete the image slider all together.


- so lets try to add some kind of growing animation to it.
- ya we are definetly to to use useSpring because we are going to have it toggle to some state.

- we know that we have to import animated and useSpring but what else do we have to do.
- so we can either overwrite the values or change the animation. we are going to go with the toggle of the properties,
I think if we set the height and width to 0 then we should be able to get a growing animation from it.
